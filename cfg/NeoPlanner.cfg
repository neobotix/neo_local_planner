#!/usr/bin/env python
PACKAGE = "neo_local_planner"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

gen.add("acc_lim_x", double_t,	0, "The x acceleration limit of the robot in meters/sec^2", 0.5, 0.0, 3.0)
gen.add("acc_lim_y", double_t, 0, "The y acceleration limit of the robot in meters/sec^2", 0.0, 0.0, 3.0)
gen.add("acc_lim_theta", double_t, 0, "The rotational acceleration limit of the robot in radians/sec^2", 0.5, 0.00, 6.28)
gen.add("acc_limit_trans",	double_t,	0, "acceleration limit translational", 0.5, 0.00, 3.0)
gen.add("min_vel_x", double_t, 0, "The minimum x velocity for the robot in m/s, negative for backwards motion", -0.1, -1.0, 1.0)
gen.add("max_vel_x", double_t, 0, "The maximum x velocity for the robot in m/s.", 1.0, 0.0, 5.0)
gen.add("min_vel_y", double_t, 0, "The minimum y velocity for the robot in m/s, negative for backwards motion", -0.1, -1.0, 1.0)
gen.add("max_vel_y", double_t, 0, "The maximum y velocity for the robot in m/s.", 1.0, 0.0, 5.0)
gen.add("min_rot_vel", double_t, 0, "The absolute value of the minimum rotational velocity for the robot in rad/s", 0.5, 0.0, 3.0)
gen.add("max_rot_vel", double_t, 0, "The absolute value of the maximum rotational velocity for the robot in rad/s", 0.5, 0.0, 3.0)
gen.add("min_trans_vel", double_t, 0, "The absolute value of the minimum translational velocity for the robot in m/s", -0.1, 0.0, 0.5)
gen.add("max_trans_vel", double_t, 0, "The absolute value of the maximum translational velocity for the robot in m/s", 0.5, 0.0, 3.0)
gen.add("rot_stopped_vel", double_t, 0, "rot_stopped_vel", 0.1, 0.0, 1.0)
gen.add("trans_stopped_vel", double_t, 0, "trans_stopped_vel", 0.1, 0.0, 1.0)
gen.add("yaw_goal_tolerance", double_t, 0, "The tolerance in radians for the controller in yaw/rotation when achieving its goal", 1.0, 0.0, 6.28)
gen.add("xy_goal_tolerance", double_t, 0, "The tolerance in meters for the controller in the x & y distance when achieving a goal", 0.1, 0.0, 10.0)

gen.add("differential_drive", bool_t, 0, "If robot has differential drive, holonomic otherwise", True)
gen.add("constrain_final", bool_t, 0, "constrain final", False)
gen.add("goal_tune_time", double_t, 0, "How long to fine tune for goal position after reaching tolerance limits [s]", 0.5, 0.0, 5.0)
gen.add("lookahead_time", double_t, 0, "How far to predict control pose into the future based on latest odometry [s]", 0.2, 0.0, 10.0)
gen.add("lookahead_dist", double_t, 0, "How far to look ahead when computing path orientation [m]", 0.5, 0.0, 20.0)
gen.add("start_yaw_error", double_t, 0, "Threshold yaw error below which we consider to start moving [rad]", 0.2, 0.0, 3.14)
gen.add("pos_x_gain", double_t, 0, "Gain when adjusting final x position for goal [1/s]", 1.0, 0.0, 10.0)
gen.add("pos_y_gain", double_t, 0, "Gain when adjusting final y position for goal [1/s]", 1.0, 0.0, 10.0)
gen.add("pos_y_yaw_gain", double_t, 0, "Gain for lane keeping based on y error (differential only) [rad/s^2]", 1.0, 0.0, 10.0)
gen.add("yaw_gain", double_t, 0, "Gain for lane keeping based on yaw error [rad/s^2]", 1.0, 0.0, 10.0)
gen.add("static_yaw_gain", double_t, 0, "Gain for adjusting yaw when not translating, or in case of holonomic drive  [1/s]", 3.0, 0.0, 10.0)
gen.add("cost_x_gain", double_t, 0, "Gain for cost function based on x error [1/s]", 0.1, 0.0, 10.0)
gen.add("cost_y_gain", double_t, 0, "Gain for cost function based on y error [1/s]", 0.1, 0.0, 10.0)
gen.add("cost_y_yaw_gain", double_t, 0, "Gain for cost function based on y error (differential only) [1/s]", 0.1, 0.0, 10.0)
gen.add("cost_y_lookahead_dist", double_t, 0, "Gain for cost function based on y error (differential only) [1/s]", 0.0, 0.0, 20.0)
gen.add("cost_y_lookahead_time", double_t, 0, "Gain for cost function based on y error (differential only) [1/s]", 1.0, 0.0, 10.0)
gen.add("cost_yaw_gain", double_t, 0, "Gain for yaw cost avoidance", 1.0, 0.0, 10.0)
gen.add("low_pass_gain_x", double_t, 0, "Gain for low pass filter for x", 0.5, 0.0, 1.0)
gen.add("low_pass_gain_y", double_t, 0, "Gain for low pass filter for y", 0.5, 0.0, 1.0)
gen.add("low_pass_gain_yaw", double_t, 0, "Gain for low pass filter for yaw", 0.5, 0.0, 1.0)
gen.add("max_cost", double_t, 0, "Maximum cost for a path to be considered valid", 0.9, 0.0, 1.0)
gen.add("max_curve_vel", double_t, 0, "Maximum velocity for a path to be considered valid", 0.2, 0.0, 1.0)
gen.add("max_goal_dist", double_t, 0, "Maximum distance to goal for a path to be considered valid", 0.5, 0.0, 1.0)
gen.add("max_backup_dist", double_t, 0, "Maximum distance to backup for a path to be considered valid", 0.1, 0.0, 1.0)
gen.add("min_stop_dist", double_t, 0, "Minimum distance to stop for a path to be considered valid", 0.5, 0.0, 1.0)
gen.add("emergency_acc_lim_x", double_t, 0, "Emergency acceleration limit in x direction", 2.0, 0.0, 10.0)
gen.add("enable_software_stop", bool_t, 0, "Enable software stop", True)
gen.add("allow_reversing", bool_t, 0, "Allow reversing", False)

exit(gen.generate(PACKAGE, "neo_local_planner", "NeoLocalPlanner"))